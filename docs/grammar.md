# 構文

CitrineScript の構文ドキュメント。

## ステートメント

プログラムは0つ以上のステートメントから成る。0つのステートメントは何もしないプログラムを意味する。
ステートメントは式を含みうる。

## 式
式は値を評価し表すもの、あるいは値そのものである。

## データ型

データ型は、値の種類のことである。

### 文字列

文字列は、言わずもがなである。

```js
"ABC ABC"

// エスケープを用いて改行やダブルクオーテーション、バックスラッシュを含められる

// おはよう
// "おはよう！"
// \('ω')/
"おはよう\n\"おはよう！\"\n\\('ω')/"
```

### 数値

CitrineScript では全ての数値は実数である。

```js
3
-5.0
// 16進数表記
0xffffffff
// 2進数表記
0b0011010010110100
```

### 真偽値

`true` `false` の2値を表す。

### null

値が無い様を表す `null`

### 配列

配列は値を順番に格納する構造体である。
型をごちゃまぜにすることもできるため、容易にジャグ配列を作成できる。

```js
score := [ 1, 1, 4, 5, 1, 4 ]

print(score[3]) // 5
score[0] = 5
print(score) // [ 5, 1, 4, 5, 1, 4 ]
```

### オブジェクト

オブジェクトはキーと値の組み合わせを複数保持する構造体である。JavaScriptのオブジェクトと似たものと思えば良い。

値には文字列や数値はもちろん、配列、オブジェクト自身、さらには関数オブジェクトも格納できる。

```js
xeltica := {
    // 変更不可能
    name := "Xeltica",
    age = 21
}

print(xeltica.name) // Xeltica
xeltica.age += 79
print(xeltica) // { name := "Xeltica", age = 100 }
```

標準ライブラリの `JSON` グループによってパースしたりシリアライズしたりできる。

### 範囲リテラル

範囲リテラルは、整数による範囲を表すものである。1から100の間、1つ飛ばし(1, 3, 5, 7, ...)を表現する場合は `1 -> 100 @ 2` と表記する。連番の場合 `@ 1` と書かなくても良い。

範囲リテラルは、実際には次のようなオブジェクトに展開される。

```js
// 1 -> 100 @ 2
{
    from: 1,
    to: 100,
    step: 2
}
```

## 演算

演算子を用いて式を作成することで、数値の演算、文字列の結合ができる。

```js
1 + 2 // 3
3 - 2 // 1
3 * 5 // 15
3 / 2 // 1.5
3 / 0 // Infinity
0 / 0 // NaN
8 % 5 // 3
"My name is " + "Xeltica." // My name is Xeltica.
```

## 変数定義

変数は型制約がなく、どんな値を入れることもできる。また、変数の宣言は代入も兼ねる。
変数定義はステートメントであるが、式でもある。

`<変数名> = <式>`

`=` の代わりに `:=` を用いることで、定数を作成できる。変数は後で値を変更できる(mutable)であるが、定数は値を変更できない(inmutable)、つまり読み取り専用である。

定数は値を変更できないだけでほかは変数と全く同じように使用できる。

変数名・定数名は式として使える。

```js
// := とすることで値を変更できなくする
name := "Xeltica"
age = 21

print("私の名前は")
print(name)
print("です。年齢は")
print(age = 17)
printLine("歳です。")
```
### 出力

```
私の名前はXelticaです。年齢は17歳です。
```

## ブロック

ブロックは複数のステートメントを含むステートメントである。
ブロック内の変数にはスコープの概念が適用される。
ブロックの外にある変数はグローバル変数であり、中にある変数はローカル変数である。

ローカル変数はそのブロックの終わりに破棄され、ブロックの外からは使うことができない。

```js
text = "おはよう"

{
    printLine(text) // "おはよう"
    o = "world"
    printLine("hello, " + o) // "hello, world"
}
printLine(text) // "おはよう"
printLine(o) // ""
```

## 関数

関数は処理をまとめたプログラムの部品である。ブロック同様にスコープの概念を持つ。
例えば、これまでの例で述べていた `printLine` は、値を出力する関数である。

関数はブロックの外および中のどちらでも宣言できる。ブロックの外で定義した関数はグローバル関数、中で定義した関数はローカル関数と呼び、ローカル関数はブロックの外からは呼び出せない。

関数は次のように定義する。

```js
func deg2rad(val) {
    if (typeof(val) != "number") {
        printLine("この値は数値ではありません")
        return -1
    }
    return val / 180 * Math.pi
}
```

仮引数は0つ以上を、カンマで区切って指定できる。

`arg...` のように引数名の末尾に `...` を指定した場合、可変長引数を作成できる。可変長引数は呼び出し側からは任意の数の引数を区切って渡すこともでき、省略することもできる。関数内部ではこの場合、 `arg` という名前の配列変数として可変長引数を受け取ることができる。

また、引数名の末尾に?を指定した場合、その引数を省略できることを宣言する。省略された引数は `null` となる。

`...` は仮引数の最後に1つだけ、`?`は省略不可能な引数の必ず後ろに配置しなければならない。

### 呼び出し

関数呼び出しは次の例のように行われる。関数呼び出しはステートメントであるが式でもある。

```cs
// 関数呼び出し
printLine("Hello, world!")

// 式として関数を使う
printLine(Math.sin(45 / 180 * Math.pi));
```

#### 出力
```
Hello, world!
0.707106781186547
```

### 関数オブジェクト

関数名単体を式として用いた場合、それは関数オブジェクトを意味する。関数オブジェクトは、変数に代入したり、他の関数の引数に指定したりできる。

```js
func hello() { printLine("Hello") }
p(hello) // [Function hello]

p := printLine
p("Hello") // Hello

p(p) // [NativeFunction printLine]
```

### 匿名関数

匿名関数は名前の付いていない即席の関数である。

次に示すように、ラムダ式と呼ばれる式を用いて定義する。

```js
hello := (name) => "Hello, " + name + "!"

printLine(hello("Citrine")) // Hello, Citrine!
```

匿名関数は式であるが、その呼出は通常の関数と同じくステートメントにもなる。つまり、こういうこともできる。

```js
(() => {
    print("Hello, functional world!"); // Hello, functional world!
})()
```

## グループ

グループは、関数やグローバル変数をまとめる概念である。オブジェクト指向言語における静的クラスのような存在である。

グループは `group <グループ名> { <関数定義および変数定義...> }` という形で定義する。

グループには関数、定数、変数の定義のみを含めることが出来る。

グループは次のように定義し、使用できる。

```js
group Citrine {
    // 変更できない
    name := "Citrine"

    // 変更できる
    age = 20

    func isKawaii(target) {
        return target == name
    }

    func grow() {
        age++
    }
}

print(Citrine.name) // "Citrine"
print(Citrine.age) // 20

print(Citrine.isKawaii("ああああ")) // false
print(Citrine.isKawaii("Citrine")) // true

// 😕
Citrine.grow()
print(Citrine.age) // 21
```

## 制御構文

### if

if ステートメントは条件分岐を行うステートメントである。

`if (<式>) <ステートメント>`

```js
a = inputNumber("数値を入れてね> ")
if (a > 5) {
    printLine("その数値は5より大きいね")
}
```

複数のステートメントを実行するときはブロックを使って上記のように書くが、基本的にはすべての場合でブロックを使うべきとされる。

#### else

else キーワードを使うと条件を満たさない場合の処理を書ける。

`if (<式>) <ステートメント> else <ステートメント>`

```js
a = inputNumber("数値を入れてね> ")
if (a > 5) {
    printLine("その数値は5より大きいね")
} else if (a < 5) {
    printLine("その数値は5未満だね")
} else {
    printLine("その数値は5だね")
}
```

#### for

for ステートメントは繰り返し構造を表す。

構文: `for (<variableName> in <iterable>) <statement>`

variableName には一時変数として宣言する変数名、iterable には配列やオブジェクト、文字列、範囲リテラルといったイテラブルな値（近日書きます）、statement には繰り返すステートメントを指定します。



```js
for (i in [ 1, 2, 3 ]) {
    printLine(i)
}
printLine()

for (i in 0 -> 10 @ 2) {
    printLine(i)
}
```

出力
```
1
2
3

0
2
4
6
8

```

## イテレーター

## 例外処理

